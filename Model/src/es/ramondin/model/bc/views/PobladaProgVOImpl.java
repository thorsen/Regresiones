package es.ramondin.model.bc.views;

import es.ramondin.model.bc.views.common.PobladaProgVO;
import es.ramondin.model.general.ExpTrendLine;
import es.ramondin.model.general.TrendLine;

import java.math.BigDecimal;

import java.util.ArrayList;

import oracle.jbo.AttributeHints;
import oracle.jbo.Row;
import oracle.jbo.RowSetIterator;
import oracle.jbo.server.ViewAttributeDefImpl;
import oracle.jbo.server.ViewObjectImpl;


// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Tue Apr 01 17:53:03 CEST 2014
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class PobladaProgVOImpl extends ViewObjectImpl implements PobladaProgVO {
    private String funcionY;
    private TrendLine t;
    
    private static final int PRECISION_DEC = 8;

    /**
     * This is the default constructor (do not remove).
     */
    public PobladaProgVOImpl() {
    }

    public void obtenerRegresion(String valoresX, String valoresY) {
        RowSetIterator rsIterator = this.createRowSetIterator(null);
        rsIterator.reset();

        while (rsIterator.hasNext()) {
            rsIterator.next();
            rsIterator.removeCurrentRow();
        }

        rsIterator.closeRowSetIterator();

        //Obtenemos valores de x e y
        ArrayList<Double> valX = new ArrayList<Double>();
        ArrayList<Double> valY = new ArrayList<Double>();

        String[] arrayValX = valoresX.split(";");
        for (int i = 0; i < arrayValX.length; i++) {
            valX.add(Double.valueOf(arrayValX[i]));
        }

        String[] arrayValY = valoresY.split(";");
        for (int i = 0; i < arrayValY.length; i++) {
            valY.add(Double.valueOf(arrayValY[i]));
        }

        double[] desv = new double[valX.size()];
        double[] frec = new double[valY.size()];

        for (int i = 0; i < valX.size(); i++) {
            desv[i] = valX.get(i);
        }

        for (int i = 0; i < valY.size(); i++) {
            frec[i] = valY.get(i);
        }

        //Hallamos la regresión
        t = new ExpTrendLine();

        t.setValues(frec, desv);
        //Creamos las nuevas filas

        double posX = desv[desv.length - 1];
        double minPosX = desv[0];
        BigDecimal valorFrec = null;

        BigDecimal resolTrend = new BigDecimal("1");

        //Añadimos una por delante y una por detrás para visualizar mejor la regresión
        Row newRow = this.createRow();
        newRow.setAttribute("Desviaciones", BigDecimal.valueOf(posX + 1000.0));
        newRow.setAttribute("Frecuencias", null);
        newRow.setAttribute("Regresion",
                            BigDecimal.valueOf(t.predict(posX + 1000.0)));
        this.insertRow(newRow);
        this.setCurrentRow(newRow);
//        this.getApplicationModule().getTransaction().commit();

        while (posX >= minPosX) {
            valorFrec = null;

            for (int i = desv.length - 1; i >= 0; i--) {
                if (desv[i] == posX) {
                    valorFrec = BigDecimal.valueOf(frec[i]);

                    break;
                } else if (desv[i] < posX)
                    break;
            }
            
            if (valorFrec != null) {
                newRow = this.createRow();
                newRow.setAttribute("Desviaciones", BigDecimal.valueOf(posX));
                newRow.setAttribute("Frecuencias", valorFrec);
                newRow.setAttribute("Regresion",
                                    BigDecimal.valueOf(t.predict(posX)));
                this.insertRow(newRow);
                this.setCurrentRow(newRow);

//                this.getApplicationModule().getTransaction().commit();
            }

            posX =
((BigDecimal.valueOf(posX)).subtract(resolTrend)).setScale(2,
                                                           BigDecimal.ROUND_HALF_UP).doubleValue();
        }

        BigDecimal c1 = BigDecimal.valueOf(t.predict(0.0));
        BigDecimal c2 =
            BigDecimal.valueOf(Math.log(t.predict(1.0) / t.predict(0.0)));

        setFuncionY(c1.setScale(PRECISION_DEC, BigDecimal.ROUND_HALF_UP) + " * e^(" +
                    c2.setScale(PRECISION_DEC, BigDecimal.ROUND_HALF_UP) + "x)");

        ViewAttributeDefImpl attr =
            ((ViewAttributeDefImpl)findAttributeDef("Regresion"));
        attr.setProperty(AttributeHints.ATTRIBUTE_LABEL, getFuncionY());
    }

    public String getValorYParaKP(String valorK, String valorP) {
        Double valK, valP;
        
        valK = Double.parseDouble(valorK);
        valP = Double.parseDouble(valorP);
        
        return BigDecimal.valueOf(valK * valP / 12.0).setScale(PRECISION_DEC, BigDecimal.ROUND_HALF_UP).toString();
    }

    public String getValorXParaY(String valorY) {
        Double valY;
        
        valY = Double.parseDouble(valorY);
        
        Double c1 = t.predict(0.0);
        Double c2 = Math.log(t.predict(1.0) / t.predict(0.0));

        return BigDecimal.valueOf(Math.log(valY / c1) / c2).setScale(PRECISION_DEC, BigDecimal.ROUND_HALF_UP).toString();
    }
    
    public String getValorYParaX(String valorX) {
        Double valX;
        
        valX = Double.parseDouble(valorX);
        
        return BigDecimal.valueOf(t.predict(valX)).setScale(PRECISION_DEC, BigDecimal.ROUND_HALF_UP).toString();
    }

    public void setFuncionY(String funcionY) {
        this.funcionY = funcionY;
    }

    public String getFuncionY() {
        return funcionY;
    }
}
